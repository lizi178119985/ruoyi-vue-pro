# 芋道框架权限设计深度分析报告

## 概述

芋道(YuDao)框架是一个基于Spring Boot的企业级开源框架，在权限设计方面集成了AOP、多租户管理、数据权限控制等多个方向。该框架提供了一套完整的权限管理注解体系，通过声明式的方式实现细粒度的权限控制。

## 权限设计架构

### 1. 核心注解设计

#### 1.1 数据权限注解 @DataPermission

**位置：** `yudao-framework/yudao-spring-boot-starter-biz-data-permission/src/main/java/cn/iocoder/yudao/framework/datapermission/core/annotation/DataPermission.java`

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DataPermission {
    /**
     * 当前类或方法是否开启数据权限
     * 即使不添加 @DataPermission 注解，默认是开启状态
     * 可通过设置 enable 为 false 禁用
     */
    boolean enable() default true;

    /**
     * 生效的数据权限规则数组，优先级高于 {@link #excludeRules()}
     */
    Class<? extends DataPermissionRule>[] includeRules() default {};

    /**
     * 排除的数据权限规则数组，优先级最低
     */
    Class<? extends DataPermissionRule>[] excludeRules() default {};
}
```

**特点：**
- 支持类级别和方法级别声明
- 默认开启状态，可通过enable=false禁用
- 支持包含和排除特定权限规则
- 方法级别注解优先级高于类级别

#### 1.2 租户忽略注解 @TenantIgnore

**位置：** `yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/aop/TenantIgnore.java`

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
public @interface TenantIgnore {
    /**
     * 是否开启忽略租户，默认为 true 开启
     * 支持 Spring EL 表达式，如果返回 true 则满足条件，进行租户的忽略
     */
    String enable() default "true";
}
```

**特点：**
- 支持Spring EL表达式动态控制
- 用于标记需要跨租户访问的方法
- 支持继承特性

### 2. AOP实现机制

#### 2.1 数据权限AOP拦截器

**位置：** `yudao-framework/yudao-spring-boot-starter-biz-data-permission/src/main/java/cn/iocoder/yudao/framework/datapermission/core/aop/DataPermissionAnnotationInterceptor.java`

```java
public class DataPermissionAnnotationInterceptor implements MethodInterceptor {
    
    @Override
    public Object invoke(MethodInvocation methodInvocation) throws Throwable {
        // 入栈
        DataPermission dataPermission = this.findAnnotation(methodInvocation);
        if (dataPermission != null) {
            DataPermissionContextHolder.add(dataPermission);
        }
        try {
            // 执行逻辑
            return methodInvocation.proceed();
        } finally {
            // 出栈
            if (dataPermission != null) {
                DataPermissionContextHolder.remove();
            }
        }
    }
    
    private DataPermission findAnnotation(MethodInvocation methodInvocation) {
        // 1. 从缓存中获取
        // 2. 从方法中获取
        // 3. 从类上获取
        // 4. 添加到缓存中
    }
}
```

**核心机制：**
- 使用栈结构管理权限注解上下文
- 支持方法嵌套调用
- 缓存机制提升性能
- 确保异常情况下的栈平衡

#### 2.2 租户忽略AOP切面

**位置：** `yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/aop/TenantIgnoreAspect.java`

```java
@Aspect
public class TenantIgnoreAspect {

    @Around("@annotation(tenantIgnore)")
    public Object around(ProceedingJoinPoint joinPoint, TenantIgnore tenantIgnore) throws Throwable {
        Boolean oldIgnore = TenantContextHolder.isIgnore();
        try {
            // 计算条件，满足的情况下，才进行忽略
            Object enable = SpringExpressionUtils.parseExpression(tenantIgnore.enable());
            if (Boolean.TRUE.equals(enable)) {
                TenantContextHolder.setIgnore(true);
            }
            // 执行逻辑
            return joinPoint.proceed();
        } finally {
            TenantContextHolder.setIgnore(oldIgnore);
        }
    }
}
```

### 3. 上下文管理

#### 3.1 数据权限上下文管理器

**位置：** `yudao-framework/yudao-spring-boot-starter-biz-data-permission/src/main/java/cn/iocoder/yudao/framework/datapermission/core/aop/DataPermissionContextHolder.java`

```java
public class DataPermissionContextHolder {
    
    private static final ThreadLocal<LinkedList<DataPermission>> DATA_PERMISSIONS =
            TransmittableThreadLocal.withInitial(LinkedList::new);

    public static DataPermission get() {
        return DATA_PERMISSIONS.get().peekLast();
    }

    public static void add(DataPermission dataPermission) {
        DATA_PERMISSIONS.get().addLast(dataPermission);
    }

    public static DataPermission remove() {
        DataPermission dataPermission = DATA_PERMISSIONS.get().removeLast();
        // 无元素时，清空 ThreadLocal
        if (DATA_PERMISSIONS.get().isEmpty()) {
            DATA_PERMISSIONS.remove();
        }
        return dataPermission;
    }
}
```

**核心特点：**
- 使用LinkedList实现栈结构
- 支持方法嵌套调用场景
- 基于TransmittableThreadLocal实现线程间传递
- 自动清理避免内存泄漏

### 4. 权限规则实现

#### 4.1 数据权限规则接口

**位置：** `yudao-framework/yudao-spring-boot-starter-biz-data-permission/src/main/java/cn/iocoder/yudao/framework/datapermission/core/rule/DataPermissionRule.java`

```java
public interface DataPermissionRule {
    
    /**
     * 返回需要生效的表名数组
     */
    Set<String> getTableNames();

    /**
     * 根据表名和别名，生成对应的 WHERE / OR 过滤条件
     */
    Expression getExpression(String tableName, Alias tableAlias);
}
```

#### 4.2 部门数据权限规则实现

**核心实现：** `DeptDataPermissionRule`

```java
@Override
public Expression getExpression(String tableName, Alias tableAlias) {
    // 1. 检查登录用户
    LoginUser loginUser = SecurityFrameworkUtils.getLoginUser();
    if (loginUser == null) {
        return null;
    }
    
    // 2. 获得数据权限
    DeptDataPermissionRespDTO deptDataPermission = loginUser.getContext(CONTEXT_KEY, DeptDataPermissionRespDTO.class);
    
    // 3. 情况一：ALL权限无需拼接条件
    if (deptDataPermission.getAll()) {
        return null;
    }
    
    // 4. 情况二：无权限返回空数据条件
    if (CollUtil.isEmpty(deptDataPermission.getDeptIds()) && Boolean.FALSE.equals(deptDataPermission.getSelf())) {
        return new EqualsTo(null, null); // WHERE null = null
    }
    
    // 5. 情况三：拼接部门和用户条件
    Expression deptExpression = buildDeptExpression(tableName, tableAlias, deptDataPermission.getDeptIds());
    Expression userExpression = buildUserExpression(tableName, tableAlias, deptDataPermission.getSelf(), loginUser.getId());
    
    // 6. 组合条件：WHERE (dept_id IN ? OR user_id = ?)
    if (deptExpression != null && userExpression != null) {
        return new ParenthesedExpressionList(new OrExpression(deptExpression, userExpression));
    }
    
    return deptExpression != null ? deptExpression : userExpression;
}
```

**权限规则配置：**
```java
// 添加部门字段配置
public void addDeptColumn(Class<? extends BaseDO> entityClass) {
    addDeptColumn(entityClass, DEPT_COLUMN_NAME);
}

// 添加用户字段配置  
public void addUserColumn(Class<? extends BaseDO> entityClass) {
    addUserColumn(entityClass, USER_COLUMN_NAME);
}
```

## 实际使用示例

### 1. 数据权限注解使用

#### 1.1 禁用数据权限示例

```java
@GetMapping("/get")
@Operation(summary = "获得登录用户信息")
@DataPermission(enable = false) // 关闭数据权限，避免只查看自己时，查询不到部门
public CommonResult<UserProfileRespVO> getUserProfile() {
    AdminUserDO user = userService.getUser(getLoginUserId());
    // ... 业务逻辑
    return success(UserConvert.INSTANCE.convert(user, userRoles, dept, posts));
}
```

#### 1.2 缓存方法禁用数据权限

```java
@Override
@DataPermission(enable = false) // 禁用数据权限，避免建立不正确的缓存
@Cacheable(cacheNames = RedisKeyConstants.DEPT_CHILDREN_ID_LIST, key = "#id")
public Set<Long> getChildDeptIdListFromCache(Long id) {
    List<DeptDO> children = getChildDeptList(id);
    return convertSet(children, DeptDO::getId);
}
```

#### 1.3 权限服务中的使用

```java
@DataPermission(enable = false) // 关闭数据权限，不然就会出现递归获取数据权限的问题
public DeptDataPermissionRespDTO getDeptDataPermission(Long userId) {
    // 获取用户数据权限逻辑
}
```

### 2. 租户忽略注解使用

#### 2.1 Controller中的跨租户接口

```java
@GetMapping("/get-id-by-name")
@PermitAll
@TenantIgnore
@Operation(summary = "使用租户名，获得租户编号", description = "登录界面，根据用户的租户名，获得租户编号")
public CommonResult<Long> getTenantIdByName(@RequestParam("name") String name) {
    TenantDO tenant = tenantService.getTenantByName(name);
    return success(tenant != null ? tenant.getId() : null);
}

@GetMapping("simple-list")
@PermitAll  
@TenantIgnore
@Operation(summary = "获取租户精简信息列表", description = "只包含被开启的租户，用于【首页】功能的选择租户选项")
public CommonResult<List<TenantRespVO>> getTenantSimpleList() {
    List<TenantDO> list = tenantService.getTenantListByStatus(CommonStatusEnum.ENABLE.getStatus());
    return success(convertList(list, this::convertToRespVO));
}
```

#### 2.2 实体类级别的租户忽略

```java
@TableName("system_tenant")
@TenantIgnore
public class TenantDO extends BaseDO {
    // 租户实体本身忽略租户隔离
}

@TableName("system_config")  
@TenantIgnore
public class ConfigDO extends BaseDO {
    // 系统配置表忽略租户隔离
}
```

#### 2.3 Service方法中的使用

```java
@TenantIgnore // 忽略租户信息，跨租户 productKey 是唯一的
public IotProductDO getProductByProductKey(String productKey) {
    return productMapper.selectByProductKey(productKey);
}
```

### 3. 综合权限控制示例

#### 3.1 支付回调接口

```java
@PostMapping("/order/notify")
@TenantIgnore // 支付回调不传递租户信息
@ApiAccessLog(operateType = EXPORT)
public String orderNotify(HttpServletRequest request) {
    // 处理支付回调逻辑
}
```

#### 3.2 定时任务

```java
@TenantIgnore // 定时任务需要处理所有租户数据
@Scheduled(cron = "0 0 1 * * ?")
public void cleanExpiredLogs() {
    // 清理过期日志
}
```

## 权限设计优势

### 1. 声明式权限控制
- 通过注解实现权限控制，代码简洁明了
- 支持类级别和方法级别的细粒度控制
- 注解可组合使用，满足复杂业务场景

### 2. 基于AOP的透明实现
- 使用Spring AOP实现权限控制，对业务代码无侵入
- 支持方法嵌套调用的权限传递
- 异常安全，确保权限上下文的正确管理

### 3. 多租户架构支持
- 提供完整的多租户隔离机制
- 支持灵活的租户忽略策略
- 基于Spring EL表达式的动态控制

### 4. 可扩展的权限规则
- 定义了清晰的权限规则接口
- 支持自定义权限规则实现
- 可配置的表字段映射机制

### 5. 高性能设计
- 注解缓存机制减少反射开销
- 基于ThreadLocal的上下文管理
- SQL级别的权限过滤，避免应用层过滤

## 总结

芋道框架的权限设计是一个综合了AOP、多租户管理、数据权限控制的完整解决方案。通过 `@DataPermission` 和 `@TenantIgnore` 两个核心注解，配合AOP切面实现和灵活的权限规则，为企业级应用提供了强大而灵活的权限控制能力。

该设计的核心优势在于：
1. **声明式API**：简单易用的注解接口
2. **透明实现**：基于AOP的无侵入设计  
3. **高度可扩展**：清晰的接口定义和实现分离
4. **企业级特性**：完整的多租户和数据权限支持
5. **高性能**：缓存和SQL级别优化

这种权限设计模式可以作为企业级应用权限管理的参考实现，特别适用于需要细粒度权限控制和多租户支持的SaaS应用场景。